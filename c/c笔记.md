1. 单一出口原则
2. 函数的声明（函数原型）
   int sum(int a, int b); // 函数声明
   int sum(int a, int b) // 函数定义
   {
     return a + b;
   }
3. %d: 格式化int
4. %f: 格式化double
5. %p: 格式化指针类型
6. %x: 格式化int为16进制
7. %u: 无符号10进制int
8. %lu: 无符号长整型（long unsigned）
9. %c: 格式化char类型
10. 指针：int *p,q;
   *p: 是一个int. p是一个指针。
11. 函数通过返回值表明函数执行的状态（是否成功执行）；函数通过指针返回实际的运算结果。
12. #define编译预处理指令，定义宏。
13. char < short< int < float < double
14. char一个字节，long double 16个字节
15. sizeof计算某个类型或某个变量在内存中的字节数
16. 补码：拿补码和原码可以加出一个溢出的”零“
    1.  十进制1为：0000 0001
    2.  十进制0为：0000 0000
    3.  十进制-1为: 0 - 1，即1111 1111
    4.  保证1+(-1)直接相加等0，简化计算机内部标识逻辑。
    5.  同理：对于-a，其补码就是0-a, 实际是2^n-a，n是这种类型的位数。
17. 除了直接操作硬件，其他直接使用int、double。现在的cpu为64位，一次传输数据的最小单元就是8个字节。
18. 编译多个文件：gcc main.c swap.c -o main.ex
19. 指针应用场景：
    1.  交换两个变量
    2.  函数返回多个值
    3.  函数返回运算状态，结果通过指针返回。
20. 指针常见错误：
    1.  定义了指针变量，没有指向任何地址就开始使用。
21. 数组：数组变量是const指针。
    ```
    // int a[] <===> int * const a
    
    int * const q = &i; // q是const 
    *q = 26; // 正确
    q++; // Error

    const int *p = &i;
    *p = 26; // Error
    i = 26; // ok
    p = &j; // ok

    void f(const int* x); // 定义一个指针，不能通过该指针修改指向的内容。常用于函数参数声明，表明函数内部不会对改指针指向的内容做修改。

    int a[]; // a这个指针不能被再次修改赋值。
    const int a[]; // a这个指针指向的元素都是const int不能被修改。

    int sum(const int a[], int len); // 表明该函数不会对array中的元素进行修改。

    ``` 
22. malloc动态申请内存
    1.  malloc申请内存后，需要手动调用free进行释放。
    2.  malloc返回的指针类型为void *
    3.  free释放时传入的指针必须为申请内存的首地址。
23. getchar/putchar
    1.  mac EOF的输入键为：control+D
24. string.h
    1.  字符型char和整型int；
    2.  字符型变量用于存储一个单一字符，在 C 语言中用 char 表示，其中每个字符变量都会占用 1 个字节（8位二进制数）。
    3.  整型int在内存中占用空间为四个字节（32位二进制数）
    4.  字符'0'：char c = '0'; 它的ASCII码实际上是48。内存中存放表示：00110000
    5.  字符'\0' :ASCII码为0，表示一个字符串结束的标志。这是转义字符（整体视为一个字符）。由于内存中存储字符，依然是存储的是对应字符集的字符编码；所以内存中的表现形式为00000000
    6.  整数0 ：内存中表示为：00000000 00000000 00000000 00000000；虽然都是0，但是跟上面字符'\0'存储占用长度是不一样的；